#!/usr/bin/perl 

use DBI;
use POSIX qw(strftime);

$_setchdir = $0;
$_setchdir =~ s/[^\/]*$//;
chdir($_setchdir);
require "./common.pl";

$dbh = DBI->connect("DBI:mysql:$DB_NAME:$DB_AUTH_HOST:$DB_AUTH_PORT",$DB_AUTH_USER,$DB_AUTH_PW) || die $DBI::errstr ;
$dbh->{RaiseError} = 1;
$dbh->do("set names utf8");

# if group is given, updates only group; updates all otherwise.
$group=$ARGV[0];

# report email
@time = localtime;
$date = strftime("%d %b %Y %H:%M:%S", @time);

#set to 2 to print logs to stdout, 1 to print logs to $verifyf dir, and 0 for no logs.
$VERIFY = 1;             
$verifyf = "$MX_LOG_ROOT/megye_varos"; 

#It should be a multi enum:
#scoring suggestions:
#0 --> no problem
#1 --> duplicate mobile phone (it is important for sms sending). 0 goes
#for the last validated member, 1 goes for
#the others with the same mobile phone number
#2 --> duplicate entrty. If (name and birth date are the same): 0 goes
#for last validated member, 2 goes for the others
#3 --> unsufficient data: If vezeteknev or keresztnev are empry or one
#character long,
#4--> liar: (eletkor < 10, > 80 and beosztás
#or
#Alkalmi vagy kisegíto~ munka 1976/101031 (1.96%) [1976/96479 (2.05%)]
#or
#Beosztott 39310/101031 (38.91%) [39310/96479 (40.74%)]
#or
#Középvezeto~ 13682/101031 (13.54%) [13682/96479 (14.18%)]
#or
#Felso~vezeto~ 2491/101031 (2.47%) [2491/96479 (2.58%)]
#or
#Cégvezeto~, tulajdonos 5570/101031 (5.51%) [5570/96479 (5.77%)]
#
#)
#or (date of birth 0000-00-00)

$vtime=time();
if ($VERIFY==1) {
    open (OO, ">$verifyf/score_trust-$vtime.notok");
    print OO "group: $group\n";
    close OO;
}
elsif ($VERIFY==2) {
    print "group: $group\n";
}

if (!length($group)) {
    $qpart="";
}
else {
    $qpart="where title='$group'";
}

$foundg=0;
$sth=$dbh->prepare("select id,title from groups $qpart order by title");
$sth->execute;
while (@row=$sth->fetchrow_array) {
    $foundg=1;
    $group_id=$row[0];
    $title=$row[1];
    $st1 = $dbh->prepare("desc users_$title");
    $st1->execute;
    undef %realdemogs;
    while (@r1 = $st1->fetchrow_array) {
        if ($r1[0] =~ /ui_(.*)/) {
            $realdemogs{$1}=1;
        }
    }
    $st1->finish;
    log_mv("\n\nProcessing $title group ......");
    if ($realdemogs{"mobil"}) {
        $i=0;
        $st2 = $dbh->prepare("update users_$title set score_trust=replace(score_trust,',1,','')");
        $st2->execute;
        $st2->finish;
        $st1=$dbh->prepare("select id,ui_mobil from users_$title where length(ui_mobil)>0
                            and validated='yes' and bounced='no' and robinson='no'
                            order by ui_mobil,tstamp desc,id desc");
        $st1->execute;
        $prev_mobil=-1;
        while (@r1=$st1->fetchrow_array) {
            $user_id=$r1[0];
            $ui_mobil=$r1[1];
            if ($ui_mobil eq $prev_mobil) {
                $st2 = $dbh->prepare("update users_$title set score_trust=concat(score_trust,',1,') where id='$user_id'");
                $st2->execute;
                $st2->finish;
                $i++;
            }
            $prev_mobil=$ui_mobil;
        }
        $st1->finish;
        log_mv("\n\n***Ready with $title group - mobiles: $i duplicates***\n\n");
    }
    if ($realdemogs{"vezeteknev"} && $realdemogs{"keresztnev"} && $realdemogs{"szuletesnap"}) {
        $i=0;
        $st2 = $dbh->prepare("update users_$title set score_trust=replace(score_trust,',2,','')");
        $st2->execute;
        $st2->finish;
        $st1=$dbh->prepare("select id,ui_vezeteknev,ui_keresztnev,ui_szuletesnap 
                            from users_$title where length(ui_vezeteknev)>0 and to_days(ui_szuletesnap)>0
                            and validated='yes' and bounced='no' and robinson='no'
                            order by ui_vezeteknev,ui_keresztnev,ui_szuletesnap,validated_date desc,id desc");
        $st1->execute;
        $prev_udata="";
        while (@r1=$st1->fetchrow_array) {
            $user_id=$r1[0];
            $udata="$r1[1]|$r1[2]|$r1[3]";
            if ($udata eq $prev_udata) {
                $st2 = $dbh->prepare("update users_$title set score_trust=concat(score_trust,',2,') where id='$user_id'");
                $st2->execute;
                $st2->finish;
                $i++;
            }
            $prev_udata=$udata;
        }
        $st1->finish;
        log_mv("\n\n***Ready with $title group - name/birthday: $i duplicates***\n\n");
        $st2 = $dbh->prepare("update users_$title set score_trust=concat(score_trust,',3,') 
                              where (length(ui_vezeteknev)<2 or length(ui_keresztnev)<2)
                              and locate(',3,',score_trust)=0");
        $st2->execute;
        $st2->finish;
        log_mv("\n\n***Ready with $title group - name insufficient data***\n\n");
    }
    if ($realdemogs{"vezeteknev"} && $realdemogs{"keresztnev"} && $realdemogs{"szuletesnap"}) {
        $st2 = $dbh->prepare("update users_$title set score_trust=concat(score_trust,',4,') 
                              where ( to_days(ui_szuletesnap)=0 or (
                              ( year(now())-year(ui_szuletesnap)<10 or year(now())-year(ui_szuletesnap)>80 ) 
                              and (',253,'=ui_jobstatus or ',254,'=ui_jobstatus or ',255,'=ui_jobstatus 
                                   or ',256,'=ui_jobstatus or ',257,'=ui_jobstatus) ) )
                              and locate(',4,',score_trust)=0");
        $st2->execute;
        $st2->finish;
        log_mv("\n\n***Ready with $title group - liar***\n\n");
    }    
}
$sth->finish;

if (!$foundg) {
    log_mv("\nUsage: score_trust updates for all groups\n
             score_trust [group] updates only for given group\n");
}

$dbh->disconnect;

rename ("$verifyf/score_trust-$vtime.notok","$verifyf/score_trust-$vtime.ok");

sub log_mv($) {
    $ls_string=shift;
    if ($VERIFY==1) {
        open (OUT, ">>$verifyf/score_trust-$vtime.notok");
        print OUT $ls_string;
        close OUT;
    }
    elsif ($VERIFY==2) {
        print $ls_string;
    }
}

